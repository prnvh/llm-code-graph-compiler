import os
import re
from nodes.registry import NODE_REGISTRY
from core.validator import validate_plan, topological_sort


def _to_snake_case(name: str) -> str:
    """Convert CamelCase node name to snake_case function name."""
    return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()


def _output_var(node_name: str) -> str:
    """Generate a variable name for a node's output."""
    return f"out_{_to_snake_case(node_name)}"


def auto_glue_code(ordered_nodes: list, edges: list, parameters: dict) -> str:
    """
    Auto-generate glue code by wiring node outputs to inputs
    in topological order using edges and parameters.
    """
    # Build a map of node -> its predecessor (the node feeding into it)
    predecessor = {}
    for source, target in edges:
        predecessor[target] = source

    lines = []
    lines.append("if __name__ == '__main__':")

    for node_name in ordered_nodes:
        func_name = _to_snake_case(node_name)
        out_var = _output_var(node_name)
        params = parameters.get(node_name, {})

        # Build argument list
        args = []

        # If this node has a predecessor, pipe its output as first argument
        if node_name in predecessor:
            pred = predecessor[node_name]
            args.append(_output_var(pred))

        # Append static parameters as keyword arguments
        for key, value in params.items():
            args.append(f'{key}="{value}"')

        arg_str = ", ".join(args)
        lines.append(f"    {out_var} = {func_name}({arg_str})")

    # Print the final output
    last_var = _output_var(ordered_nodes[-1])
    lines.append(f"    print({last_var})")

    return "\n".join(lines)


def compile_output(plan: dict) -> str:
    is_valid, errors = validate_plan(plan)

    if not is_valid:
        raise ValueError(
            "Invalid plan:\n" + "\n".join(errors)
        )

    nodes = plan.get("nodes", [])
    edges = plan.get("edges", [])
    parameters = plan.get("parameters", {})

    ordered_nodes = topological_sort(nodes, edges)
    glue_code = plan.get("glue_code", "").strip()

    output_parts: list[str] = []

    # Header
    output_parts.append("# Generated by LLM Code Graph Compiler")
    output_parts.append("# DO NOT EDIT MANUALLY\n")

    # Load templates in topological order
    for node_name in ordered_nodes:
        node = NODE_REGISTRY[node_name]
        template_path = node.template_path

        if not os.path.exists(template_path):
            raise FileNotFoundError(
                f"Template not found for node '{node_name}': {template_path}"
            )

        with open(template_path, "r", encoding="utf-8") as f:
            template_code = f.read()

        output_parts.append(f"# --- Node: {node_name} ---")
        output_parts.append(template_code.strip() + "\n")
        output_parts.append("")

    # Use LLM glue code if provided, otherwise auto-generate
    if glue_code:
        output_parts.append("# --- Execution (LLM-generated) ---")
        output_parts.append(glue_code)
    else:
        output_parts.append("# --- Execution (auto-generated) ---")
        output_parts.append(auto_glue_code(ordered_nodes, edges, parameters))

    return "\n".join(output_parts)


def write_output(code: str, path: str = "output/app.py") -> None:
    os.makedirs("output", exist_ok=True)

    with open(path, "w", encoding="utf-8") as f:
        f.write(code)

    with open("output/requirements.txt", "w", encoding="utf-8") as f:
        f.write("flask\npandas\n")

    print(f"Emitted: {path}")
    print("Emitted: output/requirements.txt")